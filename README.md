# 섹션 9. 빈 생명주기 콜백

## 빈 생명주기 콜백 시작

- 데이터베이스 커넥션 풀, 네트워크 소켓 등 애플리케이션 시작 시점에 필요한 연결을 미리 설정하고, 종료 시점에 연결을 종료하는 작업 필요.
- 스프링을 통해 초기화 작업과 종료 작업 진행 방법 탐구.

## 스프링 빈 간단한 라이프 사이클

- 객체 생성 → 의존관계 주입 (예외: 생성자 주입)
- 스프링은 의존관계 주입 완료 후 빈에게 콜백 메서드를 통해 초기화 시점을 알림.
- 스프링 컨테이너 종료 직전에 소멸 콜백 제공.

## 스프링 빈의 이벤트 라이프 사이클

1. **스프링 컨테이너 생성**
2. **스프링 빈 생성** (생성자 주입 방식에서 의존관계 주입 발생)
3. **의존관계 주입** (필드, setter 주입)
4. **초기화 콜백**
5. **사용**
6. **소멸 전 콜백**
7. **스프링 종료**

### 초기화 및 소멸 콜백

- **초기화 콜백**: 빈 생성 후 의존관계 주입 완료 시 호출.
- **소멸 전 콜백**: 빈 소멸 직전 호출.

## 참고: 객체의 생성과 초기화를 분리하자

- 생성자는 필수 정보를 받고 메모리를 할당하여 객체를 생성함.
- 초기화는 생성된 값을 활용하여 외부 커넥션을 연결하는 등 무거운 동작 수행.
- 생성자 안에서 무거운 초기화 작업을 함께 하는 것보다 객체 생성과 초기화를 명확히 나누는 것이 유지보수 관점에서 유리함.

## 스프링의 빈 생명주기 콜백 지원 방법

1. 인터페이스
2. 설정 정보에 초기화 메서드, 종료 메서드 지정
3. @PostConstruct, @PreDestroy

### 1. 인터페이스 사용

- **InitializingBean**, **DisposableBean** 인터페이스를 통한 초기화 및 소멸.
- **단점**:
    - 스프링 전용 인터페이스로, 해당 코드가 스프링에 의존.
    - 초기화 및 소멸 메서드의 이름을 변경할 수 없음.
    - 외부 라이브러리에 적용할 수 없음.

> 참고: 인터페이스를 사용하는 초기화, 종료 방법은 스프링 초창기에 사용되었으며, 현재는 더 나은 방법으로 인해 거의 사용되지 않음.

### 2. 빈 등록 초기화 및 소멸 메서드

- 설정 정보에 `@Bean(initMethod = "init", destroyMethod = "close")`처럼 초기화 및 소멸 메서드를 지정할 수 있음.

#### 설정 정보 사용 특징

- 메서드 이름을 자유롭게 지정 가능.
- 스프링 빈이 스프링 코드에 의존하지 않음.
- 외부 라이브러리에도 초기화 및 종료 메서드를 적용할 수 있음.

#### 종료 메서드 추론

- `public static final String INFER_METHOD = "(inferred)";`
- `@Bean`의 `destroyMethod` 속성에는 추론 기능이 있음.
- 라이브러리는 보통 `close`, `shutdown` 이름의 종료 메서드를 사용.
- `@Bean`의 `destroyMethod` 기본값은 `(inferred)` 등록.
- 추론 기능 사용 시, `close` 또는 `shutdown` 이름의 메서드 자동 호출.
- 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 됨.
- 추론 기능을 사용하지 않으려면 `destroyMethod=""`처럼 빈 공백 지정.

### 3. 애노테이션 사용

- **@PostConstruct**, **@PreDestroy** 애노테이션.

#### 특징

- 최신 스프링에서 가장 권장되는 방법.
- 애노테이션 하나만 붙이면 되므로 편리.
- 스프링에 종속적이지 않은 자바 표준으로, 다른 컨테이너에서도 동작.
- 컴포넌트 스캔과 잘 어울림.
- **단점**: 외부 라이브러리에는 적용할 수 없음. 외부 라이브러리를 초기화, 종료해야 할 경우 `@Bean`의 기능을 사용해야 함.

| 방법 | 설명 | 장점 | 단점 |
| --- | --- | --- | --- |
| 1. 인터페이스 | InitializingBean, DisposableBean 인터페이스를 통한 초기화 및 소멸 | 스프링에서 제공하는 기본 기능 | - 스프링 전용 인터페이스로 의존성 있음<br>- 메서드 이름 변경 불가<br>- 외부 라이브러리에 적용 불가 |
| 2. 빈 등록 초기화 및 소멸 메서드 | @Bean(initMethod = "init", destroyMethod = "close") 설정에서 초기화 및 소멸 메서드 지정 | 메서드 이름 자유롭게 지정 가능<br>스프링 코드에 의존하지 않음<br>외부 라이브러리 적용 가능 | 없음 |
| 3. 애노테이션 | @PostConstruct, @PreDestroy 애노테이션 사용 | 최신 스프링에서 권장<br>편리함<br>자바 표준으로 다른 컨테이너에서도 동작 | 외부 라이브러리에 적용 불가 |

--- 
**섹션 10. 빈 스코프**

## 빈 스코프란?
- 스프링 빈은 기본적으로 싱글톤 스코프로 생성되며, 스프링 컨테이너의 시작과 함께 생성되어 종료될 때까지 유지됨.
- 빈 스코프란 빈이 존재할 수 있는 범위를 의미.

## 다양한 스코프
| 스코프 종류  | 설명 |
|-------------|--------------------------------------------------|
| 싱글톤      | 가장 넓은 범위로, 스프링 컨테이너의 시작과 종료까지 유지 |
| 프로토타입  | 요청할 때마다 새로운 빈 생성, 이후 컨테이너가 관리하지 않음 |
| request    | HTTP 요청이 들어오고 나갈 때까지 유지 |
| session    | HTTP 세션이 생성되고 종료될 때까지 유지 |
| application | 서블릿 컨텍스트와 동일한 범위로 유지 |
| websocket  | 웹소켓과 동일한 생명 주기 |

## 프로토타입 스코프
### 싱글톤 vs 프로토타입 빈
#### **싱글톤 빈 요청 흐름**
1. 스프링 컨테이너에 싱글톤 빈 요청.
2. 스프링 컨테이너가 관리하는 동일한 인스턴스를 반환.
3. 동일한 요청이 와도 같은 객체를 반환.

#### **프로토타입 빈 요청 흐름**
1. 스프링 컨테이너에 프로토타입 빈 요청.
2. 요청 시점에 새로운 인스턴스를 생성하고 의존관계를 주입.
3. 생성된 프로토타입 빈을 반환 후 컨테이너는 관리하지 않음.
4. 이후 동일한 요청이 오면 항상 새로운 인스턴스를 반환.

### 정리
- 스프링 컨테이너는 프로토타입 빈을 생성하고 의존관계 주입, 초기화까지만 담당.
- 이후 관리는 클라이언트가 책임짐.
- 따라서 @PreDestroy 등의 종료 메서드가 호출되지 않음.

## 프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 문제점
- 싱글톤 빈이 생성될 때, 프로토타입 빈을 주입받으면 이후에도 같은 프로토타입 빈이 유지됨.
- 원하는 동작: 프로토타입 빈을 사용할 때마다 새로운 인스턴스 생성.

## 프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 Provider 활용
### 해결 방법
- **Dependency Lookup (DL, 의존관계 조회)**: 직접 필요한 시점에 프로토타입 빈을 컨테이너에서 조회.

| 방법 | 설명 |
|------|--------------------------------------------------|
| ObjectProvider | `getObject()` 호출 시 새로운 프로토타입 빈 반환 |
| JSR-330 Provider | `get()` 메서드로 간단하게 새로운 빈 반환 |

## 웹 스코프
- 웹 환경에서만 동작하며, 프로토타입과 달리 스프링이 스코프 종료 시점까지 관리함.
- 종료 메서드가 호출됨.

### request 스코프 예제
### 문제 발생
```
Error creating bean with name 'myLogger': Scope 'request' is not active for the current thread;
consider defining a scoped proxy for this bean if you intend to refer to it from a singleton
```
- request 스코프 빈은 실제 HTTP 요청이 와야 생성되므로, 생성 시점을 지연시켜야 함.
- **해결 방법**: Provider 또는 프록시 활용.

## 스코프와 Provider
- `ObjectProvider.getObject()`를 사용하면 request 스코프 빈의 생성을 지연할 수 있음.

## 스코프와 프록시
```java
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
```
### 동작 방식
- 가짜 프록시 객체를 생성해 싱글톤 빈에 미리 주입.
- 프록시 객체는 실제 요청이 오면 내부적으로 실제 request 스코프 빈을 요청하여 반환.
- **CGLIB**을 이용해 프록시 객체 생성.

| 특징 | 설명 |
|------|--------------------------------------------------|
| 프록시 사용 | 클라이언트는 마치 싱글톤 빈처럼 request 스코프 빈을 사용할 수 있음 |
| Provider와 Proxy 공통점 | 실제 객체 조회 시점을 지연 처리함 |

### 주의점
- 싱글톤처럼 보이지만 request 스코프와 다르게 동작함.
- 특별한 스코프는 필요한 곳에서만 최소한으로 사용해야 함.

---