# 목차

- [섹션 9. 빈 생명주기 콜백](#섹션-9-빈-생명주기-콜백)
- [섹션 10. 빈 스코프](#섹션-10-빈-스코프)

---

# 섹션 9. 빈 생명주기 콜백

## 빈 생명주기 콜백 개요

- 데이터베이스 커넥션 풀, 네트워크 소켓 등 애플리케이션 시작 시점에 필요한 연결을 미리 설정하고 종료 시점에 해제해야 함.
- 스프링을 활용하여 초기화 및 종료 작업을 처리하는 방법을 학습.

## 스프링 빈 라이프사이클

1. **스프링 컨테이너 생성**
2. **스프링 빈 생성** (생성자 주입 방식에서 의존관계 주입 발생)
3. **의존관계 주입** (필드, Setter 주입)
4. **초기화 콜백**
5. **사용**
6. **소멸 전 콜백**
7. **스프링 종료**

### 초기화 및 소멸 콜백

- **초기화 콜백**: 빈 생성 후 의존관계 주입 완료 시 호출.
- **소멸 전 콜백**: 빈 소멸 직전 호출.

## 객체의 생성과 초기화 분리

- **생성자**는 필수 정보를 받고 메모리를 할당하여 객체를 생성.
- **초기화**는 생성된 값을 활용하여 외부 커넥션을 연결하는 등 무거운 작업 수행.
- 유지보수를 위해 객체 생성과 초기화를 분리하는 것이 좋음.

## 스프링의 빈 생명주기 콜백 지원 방법

### 1. 인터페이스 사용

- **InitializingBean**, **DisposableBean** 인터페이스 제공.
- **단점**:
  - 스프링 전용 인터페이스로 스프링에 의존.
  - 메서드 이름을 변경할 수 없음.
  - 외부 라이브러리에 적용 불가.

### 2. `@Bean`의 `initMethod`, `destroyMethod` 사용

```java
@Bean(initMethod = "init", destroyMethod = "close")
```
- 메서드 이름을 자유롭게 지정 가능.
- 스프링 코드에 의존하지 않음.
- 외부 라이브러리에도 적용 가능.

### 3. 애노테이션 사용 (`@PostConstruct`, `@PreDestroy`)

```java
@PostConstruct
public void init() { }

@PreDestroy
public void destroy() { }
```

- 최신 스프링에서 가장 권장되는 방식.
- 스프링에 종속적이지 않은 **자바 표준**으로 다른 컨테이너에서도 동작.
- **단점**: 외부 라이브러리에는 적용할 수 없음. 외부 라이브러리에는 `@Bean` 방식 사용 필요.

### 생명주기 관리 방법 비교

| 방법 | 설명 | 장점 | 단점 |
| --- | --- | --- | --- |
| **1. 인터페이스** | InitializingBean, DisposableBean | 스프링 기본 기능 제공 | 스프링 종속성 존재, 이름 변경 불가, 외부 라이브러리 적용 불가 |
| **2. @Bean** | `initMethod`, `destroyMethod` 설정 | 메서드 이름 자유롭게 지정 가능, 외부 라이브러리 적용 가능 | 없음 |
| **3. 애노테이션** | `@PostConstruct`, `@PreDestroy` 사용 | 최신 스프링 권장, 편리함, 자바 표준 | 외부 라이브러리 적용 불가 |

---

# 섹션 10. 빈 스코프

## 빈 스코프란?

- **싱글톤 스코프**: 기본적으로 모든 스프링 빈은 싱글톤으로 생성됨.
- **빈 스코프**: 빈이 존재하는 범위를 설정하는 개념.

## 다양한 스코프

| 스코프 종류 | 설명 |
|-------------|--------------------------------------------------|
| 싱글톤 | 기본 스코프. 컨테이너 시작부터 종료까지 유지됨 |
| 프로토타입 | 요청할 때마다 새로운 빈 생성 후 컨테이너가 관리하지 않음 |
| request | HTTP 요청이 들어오고 나갈 때까지 유지 |
| session | HTTP 세션이 생성되고 종료될 때까지 유지 |
| application | 서블릿 컨텍스트와 동일한 범위로 유지 |
| websocket | 웹소켓과 동일한 생명주기 |

## 프로토타입 스코프

### 싱글톤 vs 프로토타입

#### 싱글톤 빈 요청 흐름
1. 스프링 컨테이너에서 싱글톤 빈을 요청.
2. 항상 동일한 인스턴스를 반환.

#### 프로토타입 빈 요청 흐름
1. 스프링 컨테이너에서 프로토타입 빈을 요청.
2. 새로운 인스턴스를 생성하고 의존관계를 주입.
3. 이후 컨테이너가 더 이상 관리하지 않음.

 **결론**: 프로토타입 빈은 컨테이너가 관리하지 않으므로 **@PreDestroy 등의 종료 메서드가 호출되지 않음.**

## 프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 문제점

- 싱글톤 빈이 생성될 때, 프로토타입 빈을 주입받으면 **항상 같은 프로토타입 빈을 사용하게 됨.**
- **해결 방법**: 필요한 시점에 프로토타입 빈을 새로 생성해야 함.

### 해결 방법: `ObjectProvider` 또는 `JSR-330 Provider` 사용

| 방법 | 설명 |
|------|--------------------------------------------------|
| **ObjectProvider** | `getObject()` 호출 시 새로운 프로토타입 빈 반환 |
| **JSR-330 Provider** | `get()` 메서드로 간단하게 새로운 빈 반환 |

## 웹 스코프

- **웹 환경에서만 동작**하며, 프로토타입과 달리 **스코프 종료 시점까지 스프링이 관리**함.
- **종료 메서드가 호출됨.**

### `request` 스코프 문제 해결: `ObjectProvider` 또는 프록시 활용

```java
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
```

### 프록시 동작 방식
- 가짜 프록시 객체를 생성하여 싱글톤 빈에 미리 주입.
- 실제 요청이 오면 내부적으로 request 스코프 빈을 요청하여 반환.
- **CGLIB**을 이용해 프록시 객체 생성.

| 특징 | 설명 |
|------|--------------------------------------------------|
| **프록시 사용** | 클라이언트는 마치 싱글톤 빈처럼 request 스코프 빈을 사용할 수 있음 |
| **Provider와 Proxy 공통점** | 실제 객체 조회 시점을 지연 처리함 |

### 주의점
- 싱글톤처럼 보이지만 실제로는 request 스코프와 다르게 동작.
- **특별한 스코프는 필요한 곳에서만 최소한으로 사용해야 함.**

